<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Snake — Minimal, Modern, Playable</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="description" content="A simple, modern Snake game. No dependencies. Works out-of-the-box and supports configuration via ?url= parameter." />
  <style>
    :root {
      --bg: #0f1221;
      --panel: #161a33;
      --fg: #e7ebff;
      --muted: #aab1d6;
      --accent: #7c93ff;
      --grid: rgba(255,255,255,0.06);
      --snake: #76e0a2;
      --snake-head: #9bf3bd;
      --food: #ff6b6b;
      --danger: #ff4757;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
    }

    [data-theme="light"] {
      --bg: #f7f8fc;
      --panel: #ffffff;
      --fg: #1c2340;
      --muted: #6672a3;
      --accent: #335cff;
      --grid: rgba(0,0,0,0.06);
      --snake: #1bb275;
      --snake-head: #20c884;
      --food: #ff3b30;
      --danger: #d90429;
      --shadow: 0 8px 20px rgba(0,0,0,0.12);
    }

    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 20% -10%, rgba(124,147,255,0.18), transparent 60%) no-repeat,
                  radial-gradient(900px 600px at 120% 10%, rgba(27,178,117,0.18), transparent 50%) no-repeat,
                  var(--bg);
      color: var(--fg);
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    .wrap {
      max-width: 860px;
      margin: 0 auto;
      padding: 20px 16px 40px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .title {
      display: flex;
      align-items: baseline;
      gap: 10px;
    }
    h1 {
      font-size: 22px;
      margin: 0;
      letter-spacing: 0.2px;
    }
    .sub {
      font-size: 12px;
      color: var(--muted);
    }

    .panel {
      background: var(--panel);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 12px;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 10px;
    }
    .left-controls, .right-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .btn {
      appearance: none;
      border: 0;
      background: var(--accent);
      color: white;
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: transform .06s ease, filter .2s ease, background .2s ease;
      user-select: none;
    }
    .btn:hover { filter: brightness(1.05); }
    .btn:active { transform: translateY(1px) scale(0.99); }
    .btn.secondary {
      background: transparent;
      border: 1px solid var(--grid);
      color: var(--fg);
    }
    .btn.warn {
      background: var(--danger);
    }

    .stat {
      padding: 8px 10px;
      border: 1px dashed var(--grid);
      border-radius: 10px;
      color: var(--muted);
      font-weight: 600;
      min-width: 80px;
      text-align: center;
    }

    .spacer {
      flex: 1;
    }

    .canvas-wrap {
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }

    .board {
      position: relative;
      width: 100%;
      max-width: 560px;
      margin: 0 auto;
      aspect-ratio: 1 / 1;
      border-radius: 16px;
      overflow: hidden;
      background: var(--panel);
      box-shadow: var(--shadow);
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.03)), var(--bg);
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      padding: 16px;
      background: rgba(0,0,0,0.28);
      backdrop-filter: blur(3px);
      color: var(--fg);
      text-align: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity .2s ease;
    }
    .overlay.show {
      opacity: 1;
      pointer-events: auto;
    }
    .overlay .card {
      background: var(--panel);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 16px;
      min-width: 260px;
    }
    .overlay h2 {
      margin: 6px 0 10px;
      font-size: 20px;
    }
    .overlay p {
      margin: 0 0 12px;
      color: var(--muted);
    }

    .mobile-pad {
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 8px;
      justify-content: center;
      margin: 6px auto 0;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }
    .mobile-pad .pad-btn {
      border-radius: 12px;
      background: transparent;
      border: 1px solid var(--grid);
      color: var(--fg);
      display: grid;
      place-items: center;
      font-weight: 700;
      cursor: pointer;
      transition: background .1s ease, transform .06s ease;
    }
    .mobile-pad .pad-btn:active {
      transform: translateY(1px) scale(0.98);
      background: rgba(255,255,255,0.06);
    }
    .mobile-pad .pad-btn.blank { visibility: hidden; }

    .tiny {
      font-size: 12px;
      color: var(--muted);
      text-align: center;
      margin: 6px 0 0;
    }

    .note {
      font-size: 12px;
      color: var(--muted);
      padding: 6px 8px;
    }

    .toggle {
      appearance: none;
      background: transparent;
      border: 1px solid var(--grid);
      color: var(--fg);
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(124,147,255,0.12);
      border: 1px solid rgba(124,147,255,0.3);
      color: var(--fg);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .hidden { display: none !important; }

    @media (min-width: 880px) {
      .canvas-wrap {
        grid-template-columns: 1fr 1fr;
        align-items: start;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Snake</h1>
        <span class="sub">Minimal • Modern • Playable</span>
      </div>
      <div class="row">
        <span id="configBadge" class="pill hidden" title="Loaded external configuration">Config ✓</span>
        <button id="themeBtn" class="toggle" aria-label="Toggle theme">Theme</button>
      </div>
    </header>

    <div class="panel controls" role="toolbar" aria-label="Game controls">
      <div class="left-controls">
        <button id="playBtn" class="btn" aria-pressed="false">Play</button>
        <button id="restartBtn" class="btn secondary">Restart</button>
        <div class="stat" id="scoreStat" aria-live="polite">Score: 0</div>
        <div class="stat" id="hiStat">High: 0</div>
      </div>
      <div class="right-controls">
        <label class="stat" style="padding: 6px 10px;">
          Speed
          <input id="speedRange" type="range" min="3" max="20" value="8" step="1" style="vertical-align: middle; margin-left: 8px;">
        </label>
        <label class="stat" style="padding: 6px 10px;">
          Wrap
          <input id="wrapToggle" type="checkbox" style="margin-left: 8px;">
        </label>
      </div>
    </div>

    <div class="canvas-wrap">
      <div class="board">
        <canvas id="game" width="600" height="600" aria-label="Snake game board" role="img"></canvas>

        <div id="overlay" class="overlay">
          <div class="card">
            <h2 id="overlayTitle">Snake</h2>
            <p id="overlayMsg">Press Play or use arrow keys to start.</p>
            <div class="row" style="justify-content:center; margin: 6px 0 10px;">
              <button id="overlayPlay" class="btn">Play</button>
              <button id="overlayRestart" class="btn secondary">Restart</button>
            </div>
            <div class="tiny">Controls: Arrow Keys / WASD • Pause: P • Restart: R</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div style="margin-bottom: 10px;"><strong>How to play</strong></div>
        <div class="note">
          - Use Arrow Keys or WASD to move.<br/>
          - Eat food to grow and score points.<br/>
          - Avoid hitting walls (unless Wrap is on), yourself, and obstacles.<br/>
          - Press P to pause/resume. Press R to restart.
        </div>

        <div style="margin:12px 0 8px;"><strong>Mobile D‑Pad</strong></div>
        <div class="mobile-pad" aria-label="On-screen directional pad">
          <button class="pad-btn blank" tabindex="-1"></button>
          <button id="padUp" class="pad-btn" aria-label="Up">↑</button>
          <button class="pad-btn blank" tabindex="-1"></button>
          <button id="padLeft" class="pad-btn" aria-label="Left">←</button>
          <button class="pad-btn blank" tabindex="-1"></button>
          <button id="padRight" class="pad-btn" aria-label="Right">→</button>
          <button class="pad-btn blank" tabindex="-1"></button>
          <button id="padDown" class="pad-btn" aria-label="Down">↓</button>
          <button class="pad-btn blank" tabindex="-1"></button>
        </div>

        <div class="tiny">Tip: You can configure the game via the URL parameter ?url=… See README for details.</div>
      </div>
    </div>
  </div>

  <script>
    (function () {
      'use strict';

      // ---------- Utilities ----------
      const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
      const key = (x, y) => `${x},${y}`;
      const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

      // ---------- Theme ----------
      const themeBtn = document.getElementById('themeBtn');
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const storedTheme = localStorage.getItem('snake_theme');
      const rootEl = document.documentElement;
      if (storedTheme) rootEl.setAttribute('data-theme', storedTheme);
      else rootEl.setAttribute('data-theme', prefersDark ? 'dark' : 'light');

      themeBtn.addEventListener('click', () => {
        const t = rootEl.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
        rootEl.setAttribute('data-theme', t);
        localStorage.setItem('snake_theme', t);
      });

      // ---------- Canvas / Rendering ----------
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d', { alpha: false });
      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.max(200, Math.floor(rect.width * dpr));
        canvas.height = canvas.width; // square
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      // ---------- Game State ----------
      let cols = 20;
      let rows = 20;
      let wrapWalls = false;
      let movesPerSecond = 8;
      let msPerStep = 1000 / movesPerSecond;
      let accumulator = 0;
      let lastFrame = performance.now();

      let snake = [];
      let dir = { x: 1, y: 0 };
      let nextDir = { x: 1, y: 0 };
      let food = { x: 10, y: 10 };
      let obstacles = new Set();
      let score = 0;
      let high = 0;

      let running = false;
      let gameOver = false;
      let startedOnce = false;

      // ---------- UI ----------
      const scoreStat = document.getElementById('scoreStat');
      const hiStat = document.getElementById('hiStat');
      const playBtn = document.getElementById('playBtn');
      const restartBtn = document.getElementById('restartBtn');
      const speedRange = document.getElementById('speedRange');
      const wrapToggle = document.getElementById('wrapToggle');
      const overlay = document.getElementById('overlay');
      const overlayTitle = document.getElementById('overlayTitle');
      const overlayMsg = document.getElementById('overlayMsg');
      const overlayPlay = document.getElementById('overlayPlay');
      const overlayRestart = document.getElementById('overlayRestart');
      const configBadge = document.getElementById('configBadge');

      const padUp = document.getElementById('padUp');
      const padDown = document.getElementById('padDown');
      const padLeft = document.getElementById('padLeft');
      const padRight = document.getElementById('padRight');

      // Load high score
      function hsKey() {
        return `snake_highscore_${cols}x${rows}_${wrapWalls ? 'wrap' : 'walls'}`;
      }
      function loadHigh() {
        high = Number(localStorage.getItem(hsKey()) || 0);
        hiStat.textContent = `High: ${high}`;
      }
      function saveHigh() {
        localStorage.setItem(hsKey(), String(high));
      }

      function updateSpeedUI() {
        speedRange.value = String(clamp(Math.round(movesPerSecond), Number(speedRange.min), Number(speedRange.max)));
      }

      function showOverlay(title, msg) {
        overlayTitle.textContent = title;
        overlayMsg.textContent = msg;
        overlay.classList.add('show');
      }
      function hideOverlay() {
        overlay.classList.remove('show');
      }

      // ---------- Controls ----------
      function setDirection(dx, dy) {
        // Avoid reversing immediately
        if (dir.x !== 0 && dx !== 0) return;
        if (dir.y !== 0 && dy !== 0) return;
        nextDir = { x: dx, y: dy };
        if (!running && !gameOver) startGame();
      }
      document.addEventListener('keydown', (e) => {
        if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') setDirection(0, -1);
        else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') setDirection(0, 1);
        else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') setDirection(-1, 0);
        else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') setDirection(1, 0);
        else if (e.key === 'p' || e.key === 'P') togglePause();
        else if (e.key === 'r' || e.key === 'R') resetGame(true);
      });

      // Mobile pad
      padUp.addEventListener('click', () => setDirection(0, -1));
      padDown.addEventListener('click', () => setDirection(0, 1));
      padLeft.addEventListener('click', () => setDirection(-1, 0));
      padRight.addEventListener('click', () => setDirection(1, 0));

      playBtn.addEventListener('click', () => {
        if (gameOver) { resetGame(true); return; }
        togglePause(true);
      });
      restartBtn.addEventListener('click', () => resetGame(true));
      overlayPlay.addEventListener('click', () => {
        hideOverlay();
        startGame();
      });
      overlayRestart.addEventListener('click', () => resetGame(true));

      speedRange.addEventListener('input', (e) => {
        const v = Number(e.target.value);
        movesPerSecond = clamp(v, 3, 20);
        msPerStep = 1000 / movesPerSecond;
      });
      wrapToggle.addEventListener('change', () => {
        wrapWalls = wrapToggle.checked;
        loadHigh();
      });

      function togglePause(forcePlay = false) {
        if (gameOver) return;
        if (forcePlay) {
          running = true;
          startedOnce = true;
          playBtn.textContent = 'Pause';
          playBtn.setAttribute('aria-pressed', 'true');
          hideOverlay();
          return;
        }
        running = !running;
        startedOnce = true;
        playBtn.textContent = running ? 'Pause' : 'Play';
        playBtn.setAttribute('aria-pressed', running ? 'true' : 'false');
        if (!running) showOverlay('Paused', 'Press Play or P to resume.');
        else hideOverlay();
      }

      function startGame() {
        if (gameOver) return;
        running = true;
        startedOnce = true;
        playBtn.textContent = 'Pause';
        playBtn.setAttribute('aria-pressed', 'true');
        hideOverlay();
      }

      // ---------- Game Logic ----------
      function resetGame(showStartOverlay = false) {
        const cx = Math.floor(cols / 2);
        const cy = Math.floor(rows / 2);
        snake = [{ x: cx - 1, y: cy }, { x: cx - 2, y: cy }];
        dir = { x: 1, y: 0 };
        nextDir = { x: 1, y: 0 };
        obstacles = obstacles; // keep existing obstacles as part of config
        placeFood();
        score = 0;
        updateScore();
        gameOver = false;
        running = false;
        playBtn.textContent = 'Play';
        playBtn.setAttribute('aria-pressed', 'false');
        if (showStartOverlay) showOverlay('Snake', 'Press Play or use arrow keys to start.');
      }

      function placeFood() {
        let x, y;
        const occupied = new Set(snake.map(s => key(s.x, s.y)));
        for (const o of obstacles) occupied.add(o);
        // Attempt random positions up to a limit
        for (let attempts = 0; attempts < 2000; attempts++) {
          x = randInt(0, cols - 1);
          y = randInt(0, rows - 1);
          if (!occupied.has(key(x, y))) {
            food = { x, y };
            return;
          }
        }
        // Fallback: scan
        for (let yy = 0; yy < rows; yy++) {
          for (let xx = 0; xx < cols; xx++) {
            if (!occupied.has(key(xx, yy))) {
              food = { x: xx, y: yy };
              return;
            }
          }
        }
        // If truly full, set outside (should never happen in normal play)
        food = { x: -1, y: -1 };
      }

      function updateScore() {
        scoreStat.textContent = `Score: ${score}`;
        if (score > high) {
          high = score;
          hiStat.textContent = `High: ${high}`;
          saveHigh();
        }
      }

      function step() {
        // Apply pending direction safely
        if ((dir.x === 0 && nextDir.x !== 0) || (dir.y === 0 && nextDir.y !== 0)) {
          // Prevent 180 reversal: handled by setDirection
          dir = nextDir;
        }

        const head = snake[0];
        let nx = head.x + dir.x;
        let ny = head.y + dir.y;

        if (wrapWalls) {
          nx = (nx + cols) % cols;
          ny = (ny + rows) % rows;
        } else {
          if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) {
            return doGameOver('You hit the wall!');
          }
        }

        // Self collision
        for (let i = 0; i < snake.length; i++) {
          if (snake[i].x === nx && snake[i].y === ny) return doGameOver('You bit yourself!');
        }
        // Obstacle collision
        if (obstacles.has(key(nx, ny))) return doGameOver('You hit an obstacle!');

        const ate = (nx === food.x && ny === food.y);
        snake.unshift({ x: nx, y: ny });
        if (!ate) {
          snake.pop();
        } else {
          score += 1;
          updateScore();
          placeFood();
        }
      }

      function doGameOver(reason) {
        running = false;
        gameOver = true;
        playBtn.textContent = 'Play';
        playBtn.setAttribute('aria-pressed', 'false');
        showOverlay('Game Over', `${reason} Final Score: ${score}`);
      }

      // ---------- Drawing ----------
      function draw() {
        // Determine cell size from canvas size
        const w = canvas.width;
        const h = canvas.height;
        const csX = Math.floor(w / cols);
        const csY = Math.floor(h / rows);
        const cs = Math.max(1, Math.min(csX, csY));
        ctx.clearRect(0, 0, w, h);

        // Background
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim() || '#0f1221';
        ctx.fillRect(0, 0, w, h);

        // Grid
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim() || 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 1; i < cols; i++) {
          const x = i * cs;
          ctx.moveTo(x + 0.5, 0);
          ctx.lineTo(x + 0.5, rows * cs);
        }
        for (let j = 1; j < rows; j++) {
          const y = j * cs;
          ctx.moveTo(0, y + 0.5);
          ctx.lineTo(cols * cs, y + 0.5);
        }
        ctx.stroke();

        // Obstacles
        if (obstacles.size) {
          ctx.fillStyle = 'rgba(255,255,255,0.14)';
          for (const o of obstacles) {
            const [ox, oy] = o.split(',').map(Number);
            ctx.fillRect(ox * cs, oy * cs, cs, cs);
          }
        }

        // Food
        if (food.x >= 0) {
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--food').trim() || '#ff6b6b';
          const fx = food.x * cs + cs / 2;
          const fy = food.y * cs + cs / 2;
          const r = Math.floor(cs * 0.38);
          ctx.beginPath();
          ctx.arc(fx, fy, r, 0, Math.PI * 2);
          ctx.fill();
        }

        // Snake
        const snakeColor = getComputedStyle(document.documentElement).getPropertyValue('--snake').trim() || '#76e0a2';
        const headColor = getComputedStyle(document.documentElement).getPropertyValue('--snake-head').trim() || '#9bf3bd';

        for (let i = snake.length - 1; i >= 0; i--) {
          const s = snake[i];
          const x = s.x * cs;
          const y = s.y * cs;
          ctx.fillStyle = i === 0 ? headColor : snakeColor;
          const pad = Math.max(1, Math.floor(cs * (i === 0 ? 0.08 : 0.12)));
          ctx.fillRect(x + pad, y + pad, cs - pad * 2, cs - pad * 2);
        }
      }

      // ---------- Main loop ----------
      function loop(now) {
        const dt = now - lastFrame;
        lastFrame = now;
        accumulator += dt;

        if (running && !gameOver) {
          while (accumulator >= msPerStep) {
            accumulator -= msPerStep;
            step();
          }
        }

        draw();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      // ---------- External Config via ?url= ----------
      // Supports:
      //  - ?url=https://domain/path/config.json (CORS-permitting)
      //  - ?url=json:<url-encoded-JSON>
      //  - ?url=data:application/json,<url-encoded-JSON>
      async function loadConfigFromQuery() {
        const sp = new URLSearchParams(location.search);
        const u = sp.get('url');
        if (!u) return null;

        try {
          if (u.startsWith('json:')) {
            const raw = decodeURIComponent(u.slice(5));
            return JSON.parse(raw);
          }
          // data: URLs work with fetch in modern browsers
          const res = await fetch(u, { cache: 'no-store' });
          const text = await res.text();
          try {
            return JSON.parse(text);
          } catch {
            // If it's not strict JSON, try to eval as JS object safely
            return JSON.parse(text.replace(/^\s*export\s+default\s+/, ''));
          }
        } catch (err) {
          console.warn('Failed to load external config:', err);
          return null;
        }
      }

      function applyTheme(themeObj = {}) {
        const map = {
          background: '--bg',
          panel: '--panel',
          foreground: '--fg',
          text: '--fg',
          grid: '--grid',
          accent: '--accent',
          snake: '--snake',
          snakeHead: '--snake-head',
          food: '--food',
          danger: '--danger',
        };
        for (const k in themeObj) {
          const cssVar = map[k] || null;
          if (cssVar) {
            rootEl.style.setProperty(cssVar, themeObj[k]);
          }
        }
      }

      function applyConfig(cfg) {
        if (!cfg || typeof cfg !== 'object') return;

        // Dimensions
        if (cfg.gridSize) {
          cols = rows = clamp(parseInt(cfg.gridSize, 10) || 20, 6, 80);
        }
        if (cfg.cols || cfg.columns) cols = clamp(parseInt(cfg.cols || cfg.columns, 10) || cols, 6, 120);
        if (cfg.rows) rows = clamp(parseInt(cfg.rows, 10) || rows, 6, 120);

        // Level map (array of strings, '#' = obstacle)
        if (Array.isArray(cfg.level)) {
          rows = clamp(cfg.level.length, 6, 120);
          cols = clamp(Math.max(...cfg.level.map(r => r.length)), 6, 120);
          obstacles = new Set();
          for (let y = 0; y < cfg.level.length; y++) {
            const line = cfg.level[y];
            for (let x = 0; x < line.length; x++) {
              if (line[x] === '#') obstacles.add(key(x, y));
            }
          }
        }

        // Obstacles
        if (Array.isArray(cfg.obstacles)) {
          obstacles = new Set(obstacles); // keep existing, add new
          for (const o of cfg.obstacles) {
            if (Array.isArray(o) && o.length >= 2) {
              const ox = clamp(parseInt(o[0], 10) || 0, 0, cols - 1);
              const oy = clamp(parseInt(o[1], 10) || 0, 0, rows - 1);
              obstacles.add(key(ox, oy));
            }
          }
        }

        // Rules
        if (typeof cfg.wrap === 'boolean') wrapWalls = cfg.wrap;
        if (cfg.speed) {
          movesPerSecond = clamp(Number(cfg.speed) || movesPerSecond, 3, 20);
          msPerStep = 1000 / movesPerSecond;
        }

        // Theme
        if (cfg.theme && typeof cfg.theme === 'object') applyTheme(cfg.theme);

        // UI reflect
        wrapToggle.checked = wrapWalls;
        updateSpeedUI();
        loadHigh();
      }

      // Initialize game
      updateSpeedUI();
      wrapToggle.checked = wrapWalls;
      loadHigh();
      resetGame(true);

      // Handle ?url=
      (async () => {
        const cfg = await loadConfigFromQuery();
        if (cfg) {
          applyConfig(cfg);
          resetGame(true);
          configBadge.classList.remove('hidden');
        }
      })();

      // Expose a tiny API for automated tests (optional, harmless)
      window.__snake = {
        start: startGame,
        pause: () => { running = false; showOverlay('Paused', 'Press Play or P to resume.'); },
        restart: () => resetGame(true),
        setSpeed: (s) => { movesPerSecond = clamp(s, 3, 30); msPerStep = 1000 / movesPerSecond; updateSpeedUI(); },
        setWrap: (on) => { wrapWalls = !!on; wrapToggle.checked = wrapWalls; loadHigh(); },
        applyConfig: (cfg) => { applyConfig(cfg); resetGame(true); }
      };
    })();
  </script>
</body>
</html>